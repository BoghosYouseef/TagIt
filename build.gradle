import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent
import org.gradle.api.GradleException

plugins {
    id 'java'
    id 'org.springframework.boot' version '3.5.7'
    id 'org.openjfx.javafxplugin' version '0.1.0'
}

apply plugin: 'io.spring.dependency-management'

group = 'com.tagit'
version = '0.0.1-SNAPSHOT'

java {
    sourceCompatibility = '21'
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.openjfx:javafx-controls:21.0.2'
    implementation 'org.openjfx:javafx-fxml:21.0.2'
    implementation 'org.openjfx:javafx-graphics:21.0.2'
    implementation 'org.xerial:sqlite-jdbc:3.51.1.0'
    implementation 'org.hibernate.orm:hibernate-community-dialects'
    implementation 'org.flywaydb:flyway-core:11.19.0'

    annotationProcessor "jakarta.persistence:jakarta.persistence-api:3.0.0"

    implementation platform('org.apache.logging.log4j:log4j-bom:3.0.0-beta3')

    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    developmentOnly 'org.springframework.boot:spring-boot-devtools'
    
}

tasks.named('test') {
    useJUnitPlatform()
    systemProperty "spring.profiles.active", "test" // Set the active profile for tests
    testLogging {
        // set options for log level LIFECYCLE
        events TestLogEvent.FAILED,
            TestLogEvent.PASSED,
            TestLogEvent.SKIPPED,
            TestLogEvent.STANDARD_OUT
        exceptionFormat TestExceptionFormat.FULL
        showExceptions true
        showCauses true
        showStackTraces true

        // set options for log level DEBUG and INFO
        debug {
            events TestLogEvent.STARTED,
                TestLogEvent.FAILED,
                TestLogEvent.PASSED,
                TestLogEvent.SKIPPED,
                TestLogEvent.STANDARD_ERROR,
                TestLogEvent.STANDARD_OUT
            exceptionFormat TestExceptionFormat.FULL
        }
        info.events = debug.events
        info.exceptionFormat = debug.exceptionFormat

        afterSuite { desc, result ->
            if (!desc.parent) { // will match the outermost suite
                def output = "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} passed, ${result.failedTestCount} failed, ${result.skippedTestCount} skipped)"
                def startItem = '|  ', endItem = '  |'
                def repeatLength = startItem.length() + output.length() + endItem.length()
                println('\n' + ('-' * repeatLength) + '\n' + startItem + output + endItem + '\n' + ('-' * repeatLength))
            }
        }
    }
}

tasks.named('build') {
    dependsOn(tasks.named('test'))
}


javafx {
    version = "21.0.2"
    modules = [ 'javafx.controls', 'javafx.fxml', 'javafx.graphics' ]
}

// sourceSets {
//     main {
//         resources {
//             srcDirs = ['src/main/resources', 'configuration']
//         }
//     }
    
//     test {
//         java {
//             srcDirs = ['src/test/java/com/tagit/unit', 'src/test/java/com/tagit/integration']
//         }

        
//     }
// }

tasks.register('cleanMainAppDBs', Exec) {

    group = "cleanup"
    description = "Deletes main application databases after clean"

    // Always resolve relative paths from project root
    workingDir = projectDir

    def os = System.getProperty("os.name").toLowerCase()

    try {
        if (os.contains("win")) {

            def script = "src\\main\\resources\\scripts\\deleteDatabasesAfterCleanCommand.bat"

            commandLine(
                "cmd",
                "/c",
                "call",
                script
            )

        } else if (os.contains("nix") || os.contains("nux") || os.contains("mac")) {

            def script = "src/main/resources/scripts/deleteDatabasesAfterCleanCommand.sh"

            commandLine(
                "bash",
                script
            )

        } else {
            throw new GradleException("Unsupported operating system: ${os}")
        }

    } catch (Exception e) {
        throw new GradleException("Failed to configure cleanMainAppDBs task", e)
    }
}

tasks.register('cleanTestDBs', Exec) {

    group = "cleanup"
    description = "Deletes test databases after clean"

    workingDir = projectDir

    def os = System.getProperty("os.name").toLowerCase()

    try {
        if (os.contains("win")) {

            def script = "src\\test\\resources\\scripts\\deleteDatabasesAfterCleanCommand.bat"

            commandLine(
                "cmd",
                "/c",
                "call",
                script
            )

        } else if (os.contains("nix") || os.contains("nux") || os.contains("mac")) {

            def script = "src/test/resources/scripts/deleteDatabasesAfterCleanCommand.sh"

            commandLine(
                "bash",
                script
            )

        } else {
            throw new GradleException("Unsupported operating system: ${os}")
        }

    } catch (Exception e) {
        throw new GradleException("Failed to configure cleanTestDBs task", e)
    }
}

tasks.named("clean") {
    dependsOn("cleanMainAppDBs", "cleanTestDBs")
}